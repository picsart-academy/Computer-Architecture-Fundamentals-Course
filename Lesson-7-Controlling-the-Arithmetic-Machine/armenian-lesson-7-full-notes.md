# Part 2 - opcodes and assembly
Վերհիշենք մեր առաջնային հարց֊խնդիրը՝ “ին՞չ է ծրագիրը”։ Իջնելով ամենացածր մակարդակ, հասկացանք և նույնիսկ ստեղծեցինք սարք, որը կատարում է երկուական թվերի գումարում։ Խնդիրը մնաց չլուծված, իսկապես, մենք ունենք սարք, կարող ենք ձեռքով մուտքագրել երկուական թվեր (անջատել միացնելով շղթայի բանալիները), ու սարքի շնորհիվ կարող ենք ստանալ թվերի գումարը, որպես “մոնիտոր” ունենալով լամպեր։ Վառվող լամպի տակ հասկանալով երկուական համակարգի 1 թիվը, չվառվողի դեպքում՝ երկուական 0 թիվը։ Եթե ենթադրենք, որ ունենք ոչ թե մեկ գումարիչ սարք, այլ ունենք ամեն թվաբանական գործողությանը համապատասխան մեկական սարքեր, այսինքն մեր լաբորատորիան հագեցած է հետևյալ չորս սարքերով․


![](https://paper-attachments.dropbox.com/s_8E32FA65AD6C29A5B472EA1A73B22D7572277302D6B189ADE3990750528E99F7_1493678787470_Untitled+Diagram.png)
![](https://paper-attachments.dropbox.com/s_8E32FA65AD6C29A5B472EA1A73B22D7572277302D6B189ADE3990750528E99F7_1493678787467_Untitled+Diagram+1.png)

![](https://paper-attachments.dropbox.com/s_8E32FA65AD6C29A5B472EA1A73B22D7572277302D6B189ADE3990750528E99F7_1493678787458_Untitled+Diagram+3.png)
![](https://paper-attachments.dropbox.com/s_8E32FA65AD6C29A5B472EA1A73B22D7572277302D6B189ADE3990750528E99F7_1493678787463_Untitled+Diagram+2.png)


Պայմանականորեն չենք խստացրել մուտքերն ու ելքերը, ընդունելով, որ բոլոր սարքերն էլ ստանում են նույնանման մուտքեր և տալիս են նույնանման ելքեր։
Ուշադրություն դարձրեք, սարքերից բոլորի համար (չհաշված տարօրինակ անվանումները) նշված է 8-բիտ, այսինքն պայմանավորվում ենք, որ սարքերը ընդունում են երկու՝ A և B մուտքեր, որոնցից յուրաքանչյուրը 8-բիտանոց երկուական թիվ է (այսինքն բաղկացած է 8 բիտերից, օրինակ՝ 11010011)։ Ելքում ևս, S նշանակումով ներկայացնում ենք արդյունքը, որը կրկին 8-բիտանի է, իսկ Co֊ն հնարավոր փոխանցումն է, որը, տրամաբանորեն, կարող է առաջանալ Գումարիչ ու Բազմապատկիչ սարքերում, ընդ որում Բազմապատկիչ սարքում փոխանցումը կարող է արտահայտվել 1 և ավել բիտերով, բայց մեր սարքն ի զորու է պահել 1֊բիտ փոխանցման համար, այսինքն բավականաչափ մեծ արտադրյալի դեպքում կունենանք գերլցում (overflow)։ 
Հիմա պատկերացնենք մի սարք, որտեղ երկու շարքով գնում են 8֊ական անջատիչներ, հնարավորություն տալով սարքի օգտագործողին մուտքագրել երկու 8-բիտանոց թվեր։
 

![Անջատիչներ](https://d2mxuefqeaa7sj.cloudfront.net/s_8E32FA65AD6C29A5B472EA1A73B22D7572277302D6B189ADE3990750528E99F7_1493680103873_Untitled+Diagram+4.png)


 Նկարում պատկերված է սարք, որն ունի անջատիչների երկու շարք, առաջին շարքի անջատիչների միջոցով կարող ենք մուտքագրել A 8-բիտանոց թիվը (անջատիչներն ունեն երկու դիրք, դիրքերից մեկը համապատասխանում է տվյալ բիտի 1 արժեքին, մյուս դիրքը համապատասխանում է տվյալ բիտի 0 արժեքին, ճտ֊ճտ)։ Եթե միացնենք այս մտովի հորինած սարքը Գումարիչի A և B մուտքերին, ապա Գումարիչը ելքում կտա այս անջատիչներով մուտքագրված երկու 8-բիտանոց թվերի գումարը։ Անվանեք այս անջատիչների սարքը Մուտքային Վահանակ։
 Պատկերացրեք ունենք արկղ, որտեղ տեղակայել ենք նշված չորս թվաբանական գործողություններ կատարող սարքերը։ Այդ արկղում մի շարքով տեղադրված են 8 լամպեր արդյունքի համար և մեկ լամպ՝ հնարավոր փոխանցման համար․

![Թվաբանական սարքերը՝ մեկ արկղում](https://d2mxuefqeaa7sj.cloudfront.net/s_8E32FA65AD6C29A5B472EA1A73B22D7572277302D6B189ADE3990750528E99F7_1493737149792_box.png)


Նկատենք, սարքերի մուտքերը պայմանականորեն փոփոխվել են, մասնավորապես հեռացվել է մուտքային փոխանցման լարը ը գծագիրը կրում է ավելի ընդհանուր տեսք, խճճվելուց խուսափելու համար ներկայացրել ենք հնարավորինս պարզ տեսքով։ Վերջին նկարում պատկերված արկղը՝ թվաբանական գործողություններ կատարող սարքերի և լամպերի հետ միասին, կանվանենք Թվաբանական Սարք։
Մենք կմիացնենք անջատիչների սարքը, անվանենք նրան Մուտքային Վահանակ (Input Panel), ոչ թե Գումարիչին, այլ միաժամանակ բոլոր մեր թվաբանական գործողություններ կատարող սարքերին։ Այսինքն Մուտքային Վահանակից դուրս եկող լարերի երկու խմբերը, որոնք համապատասխանաբար կրում են A և B նշանակումները, միանում են Թվաբանական սարքին, վերջինս իր հերթին լամպերի միջոցով ցույց է տալիս գործողության արդյունքը։ 


![Մուտքային Վահանակը միացված Թվաբանական սարքին](https://d2mxuefqeaa7sj.cloudfront.net/s_8E32FA65AD6C29A5B472EA1A73B22D7572277302D6B189ADE3990750528E99F7_1493738334209_comp-half.png)


 Մի քանի նկատառում․

1. A և B լարերի խումբը մեկական լարեր չեն, սխեմայում յուրաքանչյուրը պատկերված է մեկ հաստ լարով, իրականում և՛ A֊ն, և՛ B֊ն, ներկայացնում են 8-ական լարեր։ 8 լարերից յուրաքանչյուրը ներկայացնում է Մուտքային Վահանակում ընտրված բիտը՝ համապատասխանաբար A կամ B թվերի համար։
2. Դեռևս հստակ չէ, թե Մուտքային Վահանակից դուրս եկող A և B արժեքները ինչպես են միացված Թվաբանական Սարքին, արդյո՞ք միաժամանակ միացվելու են բոլոր սարքերին, թե միայն Գումարիչին։ 
3. Այս սխեմայով սարքը մեզ գործնական օգուտ չի տալիս, հստակ չեն կապերը։

Մեր նպատակն է ստեղծել մի ընդհանուր սարք, բաղկացած արդեն դիտարկված Մուտքային Վահանակից ու Թվաբանական Սարքից, որը հնարավորություն կտա մուտքագրել երկու 8-բիտանոց թվեր և կատարել չորս գործողություններից ցանկացած մեկը։ Սարքը քիչ թե շատ կսկսի նմանվել իրական համակարգչի, եթե հնարավորություն ունենանք ընտրել, թե կոնկրետ որ գործողությունն ենք ցանկանում կատարել, իսկ որ ավելի կարևոր է, կարողանանք հեշտորեն փոխել գործողությունը։ Օրինակ, ցանկանում ենք գումարել 27 (երկուականով հավասար է 00011011) և 89 (երկուականով հավասար է 01011001) թվերը, որոնց արդյունքը տեսնելու ենք Թվաբանական Սարքի լամպերի միջոցով, այն է՝ 116 (երկուականով՝ 01110100), մեր Թվաբանական Սարքի լամպերը կվառվեն հետևյալ կերպ․

![Երկուական 01110100, տասական 116](https://d2mxuefqeaa7sj.cloudfront.net/s_8E32FA65AD6C29A5B472EA1A73B22D7572277302D6B189ADE3990750528E99F7_1493739197716_bulbs.png)


Վառվող լամպը հասկանում ենք որպես տվյալ բիտի 1 արժեք, չվառվողը՝ 0 արժեք, իսկ ամենաձախ կարմիր լամպը նախատեսված է 9-րդ՝ փոխանցման բիտի համար, որը տվյալ դեպքում 0 է, չի վառվում։ 
Միտքը պարզ է, բայց պարզ չէ, թե ինչպես Թվաբանական սարքը որոշեց գումարել 27 և 89 թվերը, այլ ոչ թե բազմապատկել կամ բաժանել։ Այսինքն մեր “համակարգիչը” չունի հնարավորություն ընտրել, թե ինչ գործողություն է կատարվելու մուտքային թվերի հետ։ Դիտարկենք մեր “համակարգչի” այսպիսի լրացում․


![Ղեկավարման Վահանակը ամրացվել է Թվաբանական Սարքին](https://d2mxuefqeaa7sj.cloudfront.net/s_8E32FA65AD6C29A5B472EA1A73B22D7572277302D6B189ADE3990750528E99F7_1493739402047_comp.png)


Թվաբանական Սարքին միացվել է նոր սարք՝ Ղեկավարման Վահանակը, ուշադրություն դարձրեք նաև, որ Թվաբանական Սարքը համալրվել է չորս նոր սարքերով, որոնք պիտակավորված են որպես “2 x 8-բիտ Անջատիչ”։ Սկսենք Մուտքային Վահանակից, արդեն պարզ է դառնում, թե կոնկրետ ինչպես են միացվում Մուտքային Վահանակի լարերը մեր Թվաբանական Սարքի ներսում։ A և B մուտքերը միանում են 2 x 8-բիտ Անջատիչներին, ընդ որում, դժվար չէ տեսնել, որ յուրաքանչյուր գործողություն կատարող միավոր սարք, այն է՝ Գումարիչ, Հանիչ, Բազմապատկիչ, Բաժանիչ, յուրաքանչյուրն ունի իր 2 x 8-բիտ Անջատիչը։ Մուտքային A և B լարերը միանում են այդ յուրաքանչյուր Անջատիչին, իսկ Անջատիչից արդեն՝ համապատասխան սարքին։ 2 x 8-բիտ Անջատիչի սխեման կպատկերենք շուտով, մինչ այդ պայմանավորվենք, որ անջատիչ օգտագործելու կարևոր ու միակ նպատակն այն է, որ Ղեկավարման Վահանակի միջոցով կարողանանք նշել, թե որ սարքին ենք ցանկանում “փոխանցել ղեկավարումը”։ 
Ղեկավարման Վահանակին նայելով, տեսնում ենք երկու բանալիներ/անջատիչներ՝ S[0] և S[1] (քառակուսի փակագծերն օգտագործվել են “ինդեքս” իմաստով), իսկ անջատիչների աջ մասում չորս քառակուսի “տարրեր” են, որոնցից յուրաքանչյուրի տակ երկուական թիվ է գրված՝ 00, 01, 10, 11։ Այս թվերը երկու անջատիչներով կազմվող երկուական թվերի բոլոր կոմբինացիաներն են։ Եթե ենթադրենք, որ յուրաքանչյուր թիվ, օրինակ 01֊ը, ինչ֊որ հրաման է ներկայացնում, ապա Ղեկավարման Վահանակի միջոցով հնարավորություն ունենք չորս տարբեր հրամաններ “փոխանցել”։ Օրինակ, ճտ֊ճտ, S[0]֊ն անջատում ենք, S[1]֊ը միացնում, ստացվում է 01 թիվը, կամ երկու բանալին էլ միացնում ենք, ստացվում է 11 թիվը։ Այսպես, կարող ենք ստանալ չորս տարբեր թվեր, ու եթե հնարավորություն ունենանք “ուղղորդել” կոնկրետ կոմբինացիան կոնկրետ սարքին, այսինքն Ղեկավարման Վահանակի բանալիների 00 դիրքերի դեպքում կարողանանք “հասկացնել” Թվաբանական Սարքին, որ պետք է կատարել գումարում, այսինքն՝ “ղեկավարումը փոխանցել” Գումարիչին, կամ, նմանատիպ օրինակով, Ղեկավարման Վահանակի բանալիներ 10 դիրքերի դեպքում Թվաբանական Սարքին “հասկացնել”, որ պետք է կատարել բազմապատկում, այսինքն՝ “ղեկավարումը փոխանցել” Բազմապատկիչին, ապա, կարող ենք հպարտորեն ասել, որ ունենք թվաբանական գործողություններ կատարող սարք, որին հնարավոր է “հրամայել” կատարել նախընտրելի գործողությունը։ Այսինքն մեր հրամանների կոդերը կարող ենք ներկայացնել այսպիսի աղյուսակով․

| ADD | 00 |
| --- | -- |
| SUB | 01 |
| MUL | 10 |
| DIV | 11 |

Ստացվում է, մենք մեր սարքի համար ունենք լեզու, երկուական թվերով նրան հրամայում ենք կատարել ինչ֊որ գործողություն։
Նման տեմպերով համակարգիչն էլ սարերի հետևում չէ։
Հիմա, հավատալով մինչ այս ասվածին, հասկանանք ինչ է թաքնված Ղեկավարման Վահանակում, ինչպես պետք է դասավորել տրամաբանական տարրերը, որ տարբեր դիրքերով բանալիների արդյունքում ստանանք լարում տարբեր ելքերում։ Վահանակն ունի երկու մուտք՝ S[0] և S[1] բանալիները, և չորս ելք։ Սարքը, կամ շղթան, որը հնարավորություն է տալիս քիչ քանակի մուտքերից ստանալ շատ քանակի ելքեր, կոչվում է [Դեմուլտիպլեքսոր](https://en.wikipedia.org/wiki/Multiplexer)։ Մեր դեպքում, Ղեկավարման Վահանակն իրենից ներկայացնում է 2-4 Դեմուլտիպլեքսոր, այսինքն փոխակերպում է 2 մուտքը 4 ելքերից որևէ մեկի․


![Ղեկավարման Վահանակ՝ Դեմուլտիպլեքսոր](https://d2mxuefqeaa7sj.cloudfront.net/s_8E32FA65AD6C29A5B472EA1A73B22D7572277302D6B189ADE3990750528E99F7_1493741366671_demux.png)


Վերևի շարքում տեղադրված են AND տրամաբանական տարրեր, անկախ նրանից որ ուրիշ պիտակներ են կրում, բոլոր տարրերը AND տրամաբանական տարրերն են, միակ փոփոխությունն այն է, որ ի տարբերություն մինչ այս մեր դիտարկած AND տարրերի, սրանք ունեն երեք մուտքեր։ Անկախ մուտքերի քանակից, AND կամ OR կամ ցանկացած այլ տարր իր աշխատանքի սկզբունքը չի փոխում, կոնկրետ այս դեպքում AND֊երից յուրաքանչյուրի ելքում կստացվի 1, եթե բոլոր երեք մուտքերում լինի 1 արժեք։ Նկարում AND տարրերը նշանակված են համապատասխանաբար ADD, SUB, MUL և DIV, որովհետև մեր դեպքում՝ Դեմուլտիպլեքսորը կտա 1 այդ տարրերից միայն ու միայն մեկի ելքում, այսինքն պատկերված սխեմայի միջոցով կարող ենք հասնել մեր ընթացիկ խնդրի լուծմանը, այն է՝ երկու բանալիներով ստանալ չորս տարբեր ելքեր։ Բանալիները նկարում համապատասխանաբար պիտակավորված են S0 և S1: V֊ով նշանակված լարը միանում է բոլոր չորս տարրերին։ Ինչպես և նախորդ բոլոր սխեմաներում, V-ն հոսանքի աղբյուրն է, պատկերացրեք, որ այդ լարով միշտ հոսանք է գնում դեպի տարրերը, այսինքն AND տարրերի մուտքերից մեկը միշտ 1 է։ Փորձեք մտովի միացնել անջատել S0 և S1 բանալիները, օրինակ, եթե երկու բանալիներն էլ անջատված են, այսինքն գտնվում են 00 դիրքում, ապա ADD պիտակով AND տրամաբանական տարրի բոլոր մուտքերում ստացվում է 1 (քանի֊որ S0 և S1 բանալիներից հոսանք չի գնում, դրանք անջատված են, բայց համապատասխան լարերը միացված են ADD֊ին ինվերտորներով, իսկ ինվերտորը “շրջում” է արժեքը, այս դեպքում՝ 0֊ից 1)։ Բանալիների 00 դիրքի դեպքում SUB տարրի մուտքերից մեկին գնում է 0 արժեք (S1֊ը SUB֊ին միացված է ուղղակիորեն, արանքում չունենալով որևէ ինվերտոր), հետևաբար SUB֊ի ելքում 0 է։ Համապատասխանաբար (մտովի անցեք բոլոր տարրերին միացող լարերով), MUL և DIV տարրերի ելքերում ևս կլինի 0 արժեք։ Ստացվում է, S0, S1 բանալիների 00 դիրքի միջոցով մենք ունենք 1 արժեք միայն ADD պիտակով AND տարրի ելքում։ Իսկ եթե անհրաժեշտ է բազմապատկում, այսինքն ցանկանում ենք 1 ելք ստանալ MUL պիտակով AND տարրի ելքում։ Բավական է փոխել բանալիների դիրքը, միացնել S0֊ն, անջատել S1֊ը, ճտ֊ճտ, բանալիները կլինեն 10 դիրքում։ ADD֊ի մուտքերից մեկին (S0 լարով) կգնա 0, անկախ նրանից որ բանալին միացված է։ Այո, պատճառը չարաբաստիկ ինվերտորն է, այն շրջում է արժեքը 1֊ից 0, ստացվում է ADD֊ի մուտքերից ոչ բոլորն են 1, հետևաբար ելքում 0 է, որը մեզ ձեռնտու է։ Եթե դեռ չեք խճճվել, ապա SUB֊ի մուտքերից մեկում ևս կստացվի 0, քանի֊որ S1֊ը անջատված է, իսկ S1֊ը SUB֊ին միանում էր ուղղակիորեն։ Նույն տրամաբանությամբ,  DIV֊ի ելքում ևս ստացվում է 0։ Վերջապես, MUL֊ի բոլոր մուտքերում 1 է, որովհետև S0֊ն միացված է ուղղակիորեն, իսկ S1֊ը ինվերտորի միջոցով, հետևաբար, MUL֊ի ելքում ստացվում է 1։ Կրկին, ստացանք այն ինչ ցանկանում էինք, բանալիների դիրքերի սահմանված փոփոխությամբ կարողացանք “հաղորդել”, որ ակտիվ է MUL տարրը։
Այսպես, եթե միացնենք Ղեկավարման Վահանակի բոլոր չորս ելքերը Թվաբանական Սարքի չորս համապատասխան մուտքերին, կկարողանանք ղեկավարել Թվաբանական Սարքի միջոցով կատարվող գործողությունը։ Մինչև շամպայն բացելը, հասկանանք վերջին բաղկացուցիչը՝  2 x 8-բիտ Անջատիչը։ Այս նոր տարրի ներմուծման անհրաժեշտությունն առաջանում է, երբ փորձենք միացնել Դեմուլտիպլեքսորը Թվաբանական Սարքին ուղղակիորեն, այսինքն Ղեկավարման Վահանակի չորս ելքերը միացնենք Թվաբանական Սարքի չորս համապատասխան միավորներին (Գումարիչ, Հանիչ, Բազմապատկիչ, Բաժանիչ)։ Ոչ մի օգուտ չի ստացվի, որովհետև Թվաբանական Սարքի միավորները անմիջապես սկսում են կատարել գործողություն մուտքային A և B թվերի հետ, իսկ Ղեկավարման Վահանակի մեկ ելքային ազդանշանը կօգտագործենք նոր՝ 2 x 8-բիտ Անջատիչում այնպես, որ եթե ազդանշան կա, Անջատիչը կփոխանցի իր մուտքերին եկած A և B թվերը դեպի Գումարիչ (կամ մնացացած սարք, ամեն մի սարք ունի իր Անջատիչը), և, ընդհակառակը՝ եթե 2 x 8-բիտ Անջատիչը ազդանշան չի ստանա, ապա այն չի փոխանցի մուտքային տվյալները դեպի գործողություն կատարող սարք։ Ահա 2 x 8-բիտ Անջատիչի սխեման։


![2 x 8֊բիտ Անջատիչ](https://d2mxuefqeaa7sj.cloudfront.net/s_8E32FA65AD6C29A5B472EA1A73B22D7572277302D6B189ADE3990750528E99F7_1493746879602_switcher.png)


2 x 8-բիտ Անջատիչը բաղկացած է մագնիսից, որը ակտիվանում է, երբ Ղեկավարման Վահանակից եկած ազդանշանը 1 է, այսինքն հոսանք կա, հոսանքը միացնում է մագնիսը, մագնիսը ձգում է երկու բանալիները, արդյունքում միացնելով մուտքերը ելքին, և փոխանցում մուտքային A և B թվերը համապատասխան գործողություն կատարող սարքին։ Այսինքն Ղեկավարման Վահանակի ու բոլոր 2 x 8-բիտ Անջատիչների կապն արտահայտող վերջնական սխեման կարելի է պատկերել այսպես․


![Ղեկավարման Վահանակը միացված 2 x 8-բիտ Անջատիչներին](https://d2mxuefqeaa7sj.cloudfront.net/s_8E32FA65AD6C29A5B472EA1A73B22D7572277302D6B189ADE3990750528E99F7_1493748121956_demuxwithswitch.png)


Վերհիշելով Ղեկավարման Վահանակի աշխատանքը, հասկանալի է դառնում, որ օրինակ ADD ելքում 1 ազդանշանի դեպքում Գումարիչի համապատասխան 2 x 8-բիտ Անջատիչի մագնիսը կմիանա ու կփակի բանալիները, հետևաբար A և B մուտքային արժեքները “կհոսեն” դեպի Գումարիչ, իսկ այդ պահին, մնացած սարքերում տվյալ չի գնա, որովհետև մնացած սարքերի (Հանիչ, Բազմապատկիչ, Բաժանիչ) Անջատիչների մագնիսներն ակտիվ չեն։ Բոլոր մնացած Ղեկավարման Վահանակի ելքերի համար, կմիանա համապատասխան 2 x 8-բիտ Անջատիչը ու A և B մուտքային արժեքները “կհոսեն” դեպի համապատասխան սարք, եթե Ղեկավարման Վահանակի S0 և S1 բանալիների միջոցով, ճտ֊ճտ, համապատասպան դիրք տանք, օրինակ, 11֊ի դեպքում DIV ելքում 1 կլինի, որն էլ կմիացնի Բաժանիչի 2 x 8-բիտ Անջատիչը, որի արդյունքում լամպերով կհասկանանք թե բաժանման արդյունքն ինչ է։ Իսկ ինչու՞ է վերջին դիտարկված սարքի անվանումը 2 x 8-բիտ Անջատիչ։ Սարքի իմաստը երկու մուտքային 8-բիտանոց թվերը Թվաբանական Սարքին փոխանցելն է, կամ փոխանցման կանխելը, իսկ քանի որ թվերը երկուսն են ու յուրաքանչյուրը 8-բիտանի է, իսկ սարքն էլ անջատում/միացնում է “հոսքը”, ապա սարքի անվանումը դարձել է 2 x 8-բիտ Անջատիչ։ Իհարկե փաստ է, որ հեղինակը հորինել է սարքն ու նրա անվանումը, ոլորտի (Digital Logic Design) մասնագետները կառաջարկեն ավելի լավ լուծումներ ու անվանումներ, սա ընդամենը ուսումնական փորձարկումներ են, որոնց նպատակն է հասկանալ ինչպես է արդի պրոցեսորը կատարում հրամաններ։ Ու այդ ճանապարհին մենք ստեղծեցինք մեր սեփական, իհարկե խղճուկ, բայց պրոցեսորը, մասնավորապես կարող ենք կատարել երկուական թվերի գումարում, հոդվածում չի նշվե; բազմապատկման, հանման կամ բաժանման սարքերի կառուցվածքները, բայց գումարման սարքի ստեղծման արդյունքից վստահ ենք, որ կհաջողվի ստեղծել դրանք ևս (մասնավորապես եթե կարելի է հիմնվել Գումարիչի վրա)։ Կարևոր հատվածն այս լաբորատոր աշխատանքներից այն է, որ մենք փորձեցինք հրամաններ տալ մեր սարքին, հրամաններ, որոնք աշխատում են մուտքային տվյալների հետ (մեր դեպքում ընդամենը երկու մուտքային տվյալներ են, յուրաքանչյուրը 8-բիտ), հետևաբար, աբստրակտացնելով մուտքային տվյալների գաղափարը և, Մուտքային Վահանակի փոխարեն պատկերացնելով իրական հիշողություն, մասնավորապես RAM (Random Access Memory), սկսում ենք պատկերացնել, որ հնարավոր է կառուցել այնպիսի սխեմա, որ թվաբանական գործողությունները կկատարվեն հիշողության կոնկրետ բջիջներից ստացված տվյալների հետ, ոչ թե ձեռքով կմուտքագրվեն աղմկոտ ճտ֊ճտ անջատիչների միջոցով։
Կարևոր եզրահանգումը սակայն, այն է, որ կարողանալով պարզագույն ղեկավարման բլոկ ստեղծել, արդեն իսկ սկսում ենք պատկերացնել, թե ինչպես ենք ընդլայնում մեր հրամանների ցուցակը։ Վերևում մենք օգտագործում էինք Ղեկավարման Վահանակ, որը հիմնված էր 2-4 Դեմուլտիպլեքսորի վրա, այսինքն 2 մուտքային ազդանշանները կարող էինք փոխարինել 4 տարբեր ազդանշաններով, իսկ ին՞չ կլինի, եթե ավելի “մեծ” Դեմուլտիպլեքսոր վերցնենք, ասենք 3-8։ Ճիշտ է, մեր հրամանների քանակը կշատանա, այսինքն 3 բանալիներով կկարողանանք ներկայացնել 8 տարբեր ելքեր։ Ինչու՞ 8, որովհետև ամեն մի բանալի կարող է լինել 2 դիրքում, իսկ 3 տարբեր բանալիներով, որոնցից յուրաքանչյուրը կարող է լինել 2 դիրքում, ստանում ենք 8 տարբեր կոմբինացիա (2-ի 3 աստիճան)։ Ստացվում է, մեր չորս թվաբանական գործողությունների հրամաններին կարող են միանալ ևս չորսը։ “Համակարգչի” կառուցվածքը բարդացնելու գնով մենք կարող ենք ընդայլնել այն մինչև հարյուրավոր հրամաններ։ Ենթադրենք բացի չորս հիմնական թվաբանական գործողություններից, ունենք նաև սարքեր, որոնք կատարում են այլ գործողություններ, օրինակ բիտային տեղաշարժ, կամ քառակուսի արմատ հաշվել, կամ մոդուլ հաշվել, կամ ցանկացած այլ գործողություն անող սարք։ Համալրելով մեր “համակարգիչը” նոր սարքերով, նոր սարքերին “ղեկավարումը փոխանցելու” անհրաժեշտ հրամաններ “կստեղծենք” ավելի մեծ Ղեկավարման Վահանակի միջոցով։ Մեզ արդեն հասկանալի է, թե ինչպես է մեր “համակարգիչը” հասկանում, թե ինչ գործողություն պետք է կատարել մուտքային թվերի հետ։ Մենք ենք այն կազամակերպել այնպես, որ Դեմուլտիպլեքսորի 00 մուտքի դեպքում (բանալիների 00 դիրքի դեպքում), ելքում հոսանք գնա Գումարիչին, կարող ենք հանգիստ փոխել պայմանավորվածությունը, և, օրինակի համար, 00 մուտքի դեպքում կատարել հանում՝ փոխանցելով հոսանք համապատասխանաբար Հանիչին։ Նմանապես, Intel֊ի պրոցեսորները (կամ ցանկացած այլ պրոցեսոր ստեղծող/արտադրող ընկերության պրոցեսոր) ունեն իրենց կողմից “հասկացվող” հրամանների ցուցակ։ Այդ հրամանները, ինչպես և մեր դեպքում, կազմված են ընդամենը երկուական թվերից։ Այսինքն, եթե մենք փորձենք “հրամայել” Intel֊ի պրոցեսորին գործողություններ կատարել, ապա պետք է իմանանք այդ պրոցեսորի հրամանների ցուցակը։ Իսկ եթե անհրաժեշտություն լինի մի քանի հրամաններ “հրամայել” պրոցեսորին, որ կատարի հաջորդաբար, ապա հերթով կարող ենք մուտքագրել հրամանները համապատասխան “ղեկավարման վահանակից” և մուտքային տվյալները գրանցելու “մուտքային վահանակից” օգտվելով։ Փոխարենը, կարող ենք հեշտացնել մեր գործը, և հաջորդաբար հրամաններն ու տվյալները մուտքագրելու փոխարեն, փորձենք հիշողության ինչ֊որ հատվածում պահպանել կատարվելիք հրամանների ու տվյալների հաջորդականությունը, և պրոցեսորին մատնացույց անել, թե հիշողության որ հատվածում է գտնվում հրամանների հաջորդականությունը, որոնք նա պետք կատարի։ Հրամանների ու տվյալների հաջորդականության փոխարեն օգտագործենք ավելի ստույգ նախադասություն՝ հրամանների հաջորդականություն ու տվյալների խումբ, որոնց հետ այդ հրամաններն աշխատում են։ Այսինքն նկատի է առնվում, որ հրամանը կարող է լինել օրինակ 00 (գումարել) կամ 10 (բաժանել), իսկ տվյալների խումբը կարող է լինել, օրինակ՝ 00011011 (տասական 27) և 01011001 (տասական 89)։ Մենք խոսում էին ոչ թե մեկ հրամանի, կամ մեկ տվյալների խմբի մասին, այլ հրամանների հաջորդականության և տվյալների խմբերի մասին, այսինքն եթե փորձենք պատկերացնել այսպիսի հաջորդականություն․

    00 00011011 01011001
    10 01011001 00011011
    11 10100 101

ու, պայմանավորվենք, որ յուրաքանչյուր տողում առաջին երկուական թիվը դա գործողության կոդն է (operation code), իսկ հաջորդ երկուական թվերը այն արժեքը կամ արժեքները, որոնց հետ աշխատում է այդ գործողությունը (որոնց վրա կիրառվում է այդ հրամանը), ապա բերված երկուական թվերի երեք տողերը վերծանված կնշանակեն․

    գումարել 27 և 89 թվերը
    բազմապատկել 89 և 27 թվերը
    բաժանել 20 և 5 թվերը 

Փաստորեն, վերջին դիտարկված երկուական թվերի հաջորդականությունը հասկանալի է մեր “համակարգչին” (եկեք անվանենք “պրոցեսոր”, ի վերջո համակարգիչն ունի այլ լրացուցիչ հավելումներ, որոնք հիմնովին բացակայում են մեր “պրոցեսորի” միջավայրում), նույնը իհարկե ի զորու չենք գրել հայերենով ու հուսանք, որ մեր “պրոցեսորը” կհասկանա։ Այո֊այո, մոտենում ենք կուլմինացիային։ Ին՞չ ենք մենք ստեղծել։ Ճիշտ է՝ մեքենա։ Ին՞չ էին մենք գրել երկուական թվերով։ Ճիշտ է՝ հրամաններ և տվյալներ, կամ պարզապես՝ **կոդ**։ Ստացվում է մեր գրած կոդը, որը հասկանում է մեքենան ու կատարում է համապատասխան հրամանները՝ աշխատելով տվյալների հետ, իրենից ներկայացնում է․․․ին՞չ, այո՛, մեքենայական կոդ (ծափահարություններ)։ 

Խնդիրներ կառաջանան այն ժամանակ, երբ ընդլայնենք մեր “պրոցեսորը”՝ նոր հրամաններ ավելացնելով (հետևաբար և նոր կոդեր)։ Նախ, երկուական թվերով մի քանի տողից շատ հրամաններ ու տվյալներ գրելով շատ շուտ կխճճվենք, կսխալվենք ու եթե ինչ֊որ տրամաբանական սխալ թույլ տանք, ասենք պետք է գումարման փոխարեն հանում օգտագործեինք ծրագրի 14֊րդ տողում, ապա այդ սխալը ման գալը, կամ ժարգոնով ասած՝ դեբագ անելը, կլինի երկարատև, տհաճ և ցավալի։ Վերջիվերջո, նույնիսկ մտապահելն է դժվարանում երբ պետք է հիշես, թե գումարման համար որ կոդն է համապատասխանում, իսկ բիտային ցիկլիկ տեղաշարժի համար որը։

Այս կարճ ու բովանդակալից երկխոսությունից հանգում ենք ասեմբլերի անհրաժեշտությանը։ Ասեմբլերը որպես այդպիսին լեզու չէ, կարելի է ասել, պրոցեսորի կողմից հասկացվող երկուական հրամանների բառային նկարագրությունն է։ Մինչև հիմա մենք գտնվում էինք ծրագրավորման աշխարհի ամենացածր մակարդակի վրա, հիմա մենք մի մակարդակ կփորձենք բարցրանալ, ի վերջո, զարգանում ենք։ Մեր “պրոցեսորի” հրամանների համար հորինենք բառային հապավումներ ու, պայմանավորվենք թվերը գրել տասական համակարգով։ Այս ամենն ընդամենը մեր հարմարության համար, “պրոցեսորը” այս ամենից տեղյակ չի լինի, այսպես թե այնպես, “պրոցեսորին” աշխատեցնելու համար ստիպված ենք բառային հապավումները փոխարինել հրամանների երկուական կոդերով, իսկ օգտագործված թվերը տասականից բերել երկուական համակարգ։ Ահա մեր “պրոցեսորի” հրամանների բառային հապավումները․

| ADD | 00 |
| --- | -- |
| SUB | 01 |
| MUL | 10 |
| DIV | 11 |

Ստացվում է, այս կոդը, որը հասկանալի է “պրոցեսորին”․


    00 00011011 01011001
    10 01011001 00011011
    11 10100 101

 մեր նոր հապավումներով և տասական համակարգ կիրառելով կունենա հետևյալ տեսքը․
 

    ADD 27 89
    MUL 89 27
    DIV 20 5

Այ սա ուրի՜շ, սա արդեն հայերեն է։ Նման կոդ ընթերցելիս կարելի է արագ կողմնորոշվել, թե ինչ գործողություններ են կատարվում։ Հիմա կարող ենք տարբեր մեծության ու բարդության ծրագրեր կազմել (չնայած ցիկլի օպերատորի բացակայության պատճառով դժվար թե կարողանանք բարդ ծրագրեր գրել)։ Իսկ ինչպե՞ս կհասկանա մեր “պրոցեսորը” այս “ասեմբլերով” կոդը։ Ոչ մի ձևով չի հասկանա, մենք կարող ենք գրել այս “ասեմբլերով” կոդ՝ մեր հարմարվետության համար, բայց երբ անհրաժեշտ լինի կոդը աշխատեցնել, մենք ստիպված ենք ձեռքով թարգմանել այն երկուական տեսքի, կամ ավելի ստույգ՝ մեքենայական կոդի, այնուհետև մուտքագրել և աշխատեցնել։

Վերջապես, հասկացանք թե ինչպես է աշխատում ծրագիրը, հաջորդ հոդվածներում մենք կխորանանք, թե ինչ է պրոցեսորի արխիտեկտուրան, ինչպես է աշխատում հիշողության հետ, ինչ է հիշողությունը իրենից ներկայացնում և, իհարկե, ինչպես ստեղծել հիշողություն տնային պայմաններում։ Բացի այդ, կմանրամասնենք բարձր մակարդակի լեզվից ցածր մակարդակի անցնելու փուլերը։ Այս պահին մենք պատկերացնում ենք ինչ է մեքենայական կոդը, ու, արդեն հասկանում, թե ինչու է բարձր մակարդակի լեզվով, օրինակ՝ C++֊ով, գրված կոդը թարգմանվում ի վերջո մեքենայական կոդի։ Ամեն դեպքում, կարող ենք հայտարարել, որ ի վիճակի ենք գրել ծրագիր՝ առանց ծրագրավորման լեզվի, անմիջապես մեքենայական կոդ։ Մինչև հիմա դա կարող էր անել միայն Ջոն Քարմակը։ 

